using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace Dreamine.MVVM.Generators
{
	[Generator]
	public sealed class RelayCommandSourceGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			// Attribute Symbol 확보
			var relayAttrSymbol = context.CompilationProvider
				.Select<Compilation, INamedTypeSymbol?>(static (c, _) =>
					c.GetTypeByMetadataName("Dreamine.MVVM.Attributes.RelayCommandAttribute"));

			// 후보 메서드 + Attribute 비교
			var methods = context.SyntaxProvider
				.CreateSyntaxProvider(
					static (s, _) => s is MethodDeclarationSyntax { AttributeLists.Count: > 0 },
					static (ctx, _) => ctx
				)
				.Combine(relayAttrSymbol)
				.Select(static (pair, _) =>
				{
					var ctx = pair.Left;
					var attrSymbol = pair.Right;
					return GetCandidateMethodSymbolBased(ctx, attrSymbol);
				})
				.Where(static m => m is not null)
				.Select(static (m, _) => m!.Value);

			// 소스 생성
			context.RegisterSourceOutput(methods, (spc, method) =>
			{
				var source = GenerateCommandPropertyCode(method);

				var ns = Sanitize(method.Symbol.ContainingNamespace.ToDisplayString());
				var className = method.Symbol.ContainingType.Name;
				var methodName = method.Symbol.Name;
				var fileName = $"{ns}_{className}_{methodName}_Command.g.cs";

				spc.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
			});
		}

		private static (MethodDeclarationSyntax Syntax, IMethodSymbol Symbol)? GetCandidateMethodSymbolBased(
			GeneratorSyntaxContext context, INamedTypeSymbol? relayAttrSymbol)
		{
			if (context.Node is not MethodDeclarationSyntax methodSyntax)
				return null;

			var symbol = context.SemanticModel.GetDeclaredSymbol(methodSyntax);
			if (symbol is not IMethodSymbol methodSymbol)
				return null;

			var hasAttribute = methodSymbol
				.GetAttributes()
				.Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, relayAttrSymbol));

			if (hasAttribute)
				return (methodSyntax, methodSymbol);

			return null;
		}

		private static string GenerateCommandPropertyCode((MethodDeclarationSyntax Syntax, IMethodSymbol Symbol) method)
		{
			var symbol = method.Symbol;
			var methodName = symbol.Name;
			var commandName = methodName + "Command";

			var className = symbol.ContainingType.Name;
			var ns = symbol.ContainingNamespace.ToDisplayString();

			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated />");
			sb.AppendLine("using Dreamine.MVVM.Core;");
			sb.AppendLine("using System.Windows.Input;");
			sb.AppendLine($"namespace {ns}");
			sb.AppendLine("{");
			sb.AppendLine($"    public partial class {className} : ViewModelBase");
			sb.AppendLine("    {");
			sb.AppendLine($"        private ICommand _{commandName};");
			sb.AppendLine($"        public ICommand {commandName} => _{commandName} ??= new RelayCommand({methodName});");
			sb.AppendLine("    }");
			sb.AppendLine("}");
			return sb.ToString();
		}

		private static string Sanitize(string name)
		{
			return name.Replace('.', '_').Replace('+', '_');
		}
	}
}
